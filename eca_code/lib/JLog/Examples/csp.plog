% Computational Intelligence: a logical approach. 
% Prolog Code from Appexdix B.
% Copyright (c) 1998, Poole, Mackworth, Goebel and Oxford University Press.
% Standard BUILT-INS (from App B)

% notin(X,L)
notin(_,[]).
notin(A,[H|T]) :-
   \+ A = H,
   notin(A,T).

% member(X,L) is true if X is a member of list L
member(X,[X|_]).
member(X,[_|L]) :-
   member(X,L).

% subset(L1,L2) is true if L1 is a subset of list L2
subset([],_).
subset([A|B],L) :-
   member(A,L),
   subset(B,L).

% append(A,B,R) is true if R is the list containing the 
% elements of A followed by the elements of B
append([],R,R).
append([H|T],L,[H|R]) :-
   append(T,L,R).

% nth(N,L,E) is true if E is the Nth element of list L
% this requires N to be bound.
nth(1,[E|_],E) :- !.
nth(N,[_|R],E) :-
   N1 is N-1,
   nth(N1,R,E).

% remove(E,L,R) is true if E is an element of L and R is the remaining
% elements after E is removed.
remove(E,[E|R],R).
remove(E,[A|L],[A|R]) :-
   remove(E,L,R).

% min(A,B,M) is true if M is the minimum of A and M
min(A,B,A) :- 
   A < B,!.
min(A,B,B) :- 
   A >= B.

% insert(E,L,L1) inserts E into L producing L1 
% E is not added it is already there.
% this assumes that E and L are ground
insert(X,[],[X]).
insert(A,[A|R],[A|R]) :- !.
insert(A,[B|R],[B|R1]) :-
%   A \== B,
   insert(A,R,R1).

% writel(L) is true if L is a list of items 
% to be written on a line.
writel([]).
writel([H|T]) :- write(H), writel(T).

% writeln(L) is true if L is a list of items 
% to be written on a line, followed by a newline.
writeln(L) :- 
   writel(L),
   nl.

% csp(Domains, Relations) means that each variable has
% an instantiation to one of the values in its Domain 
% such that all the Relations are satisfied.
% Domains represented as list of 
% [dom(V,[c1,...,cn]),...]
% Relations represented as [rel([X,Y],r(X,Y)),...]
%  for some r
csp(Doms,Relns) :-
   ac(Doms,Relns).

% ac(Dom,Relns) is true if the domain constraints
% specified in Dom and the binary relations
% constraints specified in Relns are satisfied.
ac(Doms,Relns) :-
   make_arcs(Relns,A),
   consistent(Doms,[],A,A).

% make_arcs(Relns, Arcs) makes arcs Arcs corresponding to
% relations Relns. There are arcs for each ordering of
% variables in a relations.
make_arcs([],[]).
make_arcs([rel([X,Y],R)|O],
          [rel([X,Y],R),rel([Y,X],R)|OA]) :-
   make_arcs(O,OA).

% consistent(Doms,CA,TDA,A) is true if
% Doms is a set of domains
% CA is a set of consistent arcs,
% TDA is a list of arcs to do
% A is a list of all arcs
consistent(Doms,CA,TDA,A) :-
   consider(Doms,RedDoms,CA,TDA),
   solutions(RedDoms,A).            

% consider(D0,D1,CA,TDA)
% D0 is the set of initial domains
% D1 is the set of reduced domains
% CA = consistent arcs, 
% TDA = to do arcs
consider(D,D,_,[]).
consider(D0,D3,CA,[rel([X,Y],R)|TDA]) :-
   choose(dom(XV,DX),D0,D1),X==XV,
   choose(dom(YV,DY),D1,_),Y==YV, !,
   prune(X,DX,Y,DY,R,NDX),
   ( NDX = DX
   ->
     consider(D0,D3,[rel([X,Y],R)|CA],TDA)
   ; acc_todo(X,Y,CA,CA1,TDA,TDA1),
     consider([dom(X,NDX)|D1],D3,
              [rel([X,Y],R)|CA1],TDA1)).

% prune(X,DX,Y,DY,R,NDX)
% variable X had domain DX
% variable Y has domain DY
% R is a relation on X and Y
% NDX = {X in DX | exists Y such that R(X,Y) is true}
prune(_,[],_,_,_,[]).
prune(X,[V|XD],Y,YD,R,XD1):-
   \+ (X=V, member(Y,YD), call(R)),!,
   prune(X,XD,Y,YD,R,XD1).
prune(X,[V|XD],Y,YD,R,[V|XD1]):-
   prune(X,XD,Y,YD,R,XD1).

% acc_todo(X,Y,CA,CA1,TDA,TDA1)
% given variables X and Y,
% updates consistent arcs from CA to CA1 and
% to do arcs from TDA to TDA1
acc_todo(_,_,[],[],TDA,TDA).        
acc_todo(X,Y,[rel([U,V],R)|CA0],
         [rel([U,V],R)|CA1],TDA0,TDA1) :-
   ( X \== V
   ; X == V,
     Y == U),   
   acc_todo(X,Y,CA0,CA1,TDA0,TDA1).
acc_todo(X,Y,[rel([U,V],R)|CA0],
         CA1,TDA0,[rel([U,V],R)|TDA1]) :-
   X == V,
   Y \== U,
   acc_todo(X,Y,CA0,CA1,TDA0,TDA1).

% solutions(Doms,Arcs) given a reduced set of
% domains, Doms, and arcs Arcs, solves the CSP.
solutions(Doms,_) :-
   solve_singletons(Doms).
solutions(Doms,A) :-
   select(dom(X,[XV1,XV2|XVs]),Doms,ODoms),
   split([XV1,XV2|XVs],DX1,DX2),
   acc_todo(X,_,A,CA,[],TDA),
   ( consistent([dom(X,DX1)|ODoms],CA,TDA,A)
   ; consistent([dom(X,DX2)|ODoms],CA,TDA,A)).

% solve_singletons(Doms) is true if Doms is a
% set of singleton domains, with the variables
% assigned to the unique values in the domain
solve_singletons([]).
solve_singletons([dom(X,[X])|Doms]) :-
   solve_singletons(Doms).

% select(E,L,L1) selects the first element of
% L that matches E, with L1 being the remaining
% elements.
select(D,Doms,ODoms) :-
   remove(D,Doms,ODoms), !.

% choose(E,L,L1) chooses an element of
% L that matches E, with L1 being the remaining
% elements.
choose(D,Doms,ODoms) :-
   remove(D,Doms,ODoms).

% split(L,L1,L2) splits list L into two lists L1 and L2
% with the about same number of elements in each list.
split([],[],[]).
split([A],[A],[]).
split([A,B|R],[A|R1],[B|R2]) :-
   split(R,R1,R2).

% Here is a simple example using the CSP solver
test_csp(X,Y,Z) :-
    csp([dom(X,[1,2,3,4]),
         dom(Y,[1,2,3,4]),
         dom(Z,[1,2,3,4])],
        [rel([X,Y],X<Y),rel([Y,Z],Y<Z)]).

% | ?- test_csp(X,Y,Z).
% JLog in .83
% PJ in 5.43

% Here's the scheduling problem from Chapter 4:
schedule(A,B,C,D,E) :-
    csp([dom(A,[1,2,3,4]),
         dom(B,[1,2,4]),
         dom(C,[1,3,4]),
         dom(D,[1,2,3,4]),
         dom(E,[1,2,3,4])],
        [rel([A,B], A =\= B),
         rel([B,C], B =\= C),
         rel([C,D], C < D),         
         rel([B,D], B =\= D),
         rel([A,D], A =:= D),
         rel([A,E], A > E),
         rel([B,E], B > E),
         rel([C,E], C > E),
         rel([D,E], D > E)]).

% | ?- schedule(A,B,C,D,E).
% JLog in 3.53
% PJ in 24.34
